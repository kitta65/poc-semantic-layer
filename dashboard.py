import marimo

__generated_with = "0.14.17"
app = marimo.App(width="medium")


@app.cell
def _():
    import marimo as mo
    import altair as alt
    import polars as pl
    import os
    return alt, mo, os, pl


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""# SQL API""")
    return


@app.cell
def _():
    import sqlalchemy
    return (sqlalchemy,)


@app.cell
def _(os, sqlalchemy):
    _password = os.environ.get("POSTGRES_PASSWORD", "password")
    DATABASE_URL = f"postgresql://username:{_password}@localhost:15432/test"
    engine = sqlalchemy.create_engine(DATABASE_URL)
    return (engine,)


@app.cell
def _(engine, mo, orders):
    df_sql_api = mo.sql(
        f"""
        SELECT
          DATE_TRUNC('quarter', orders.created_at) as quarter,
          MEASURE(orders.count_user) as count_user
        FROM
          orders
        GROUP BY
          1
        LIMIT
          10000;
        """,
        engine=engine
    )
    return (df_sql_api,)


@app.cell
def _(alt, df_sql_api):
    # generated by built-in chart builder
    # see https://docs.marimo.io/guides/working_with_data/plotting/#chart-builder
    _chart = (
        alt.Chart(df_sql_api)
        .mark_bar()
        .encode(
            x=alt.X(field='quarter', type='temporal', timeUnit='yearmonthdate'),
            y=alt.Y(field='count_user', type='quantitative', aggregate='mean'),
            tooltip=[
                alt.Tooltip(field='quarter', timeUnit='yearmonthdate', title='quarter'),
                alt.Tooltip(field='count_user', aggregate='mean', format=',.0f')
            ]
        )
        .properties(
            height=290,
            width='container',
            config={
                'axis': {
                    'grid': False
                }
            }
        )
    )
    _chart
    return


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""# GraphQL API""")
    return


@app.cell
def _():
    from graphql_client import Client, OrderBy
    from graphql_client.custom_fields import (
        OrdersMembersFields,
        ResultFields,
        TimeDimensionFields,
    )
    from graphql_client.input_types import OrdersOrderByInput
    from graphql_client.custom_queries import Query
    return (
        Client,
        OrderBy,
        OrdersMembersFields,
        OrdersOrderByInput,
        Query,
        ResultFields,
        TimeDimensionFields,
    )


@app.cell
def _(Client):
    client = Client(url="http://localhost:4000/cubejs-api/graphql")
    return (client,)


@app.cell
def _(client, pl):
    async def pl_from_query(query, operation_name="temp_query"):
        data = await client.query(query, operation_name=operation_name)
        data = data["cube"]
        data = map(
            # NOTE: currently only one field is allowed (extracts first data here!)
            lambda x: next(iter(x.values())),
            data,
        )
        data = map(
            flaten_if_time_dimension,
            data,
        )
        return pl.from_dicts(data)


    def flaten_if_time_dimension(dict_):
        res = {}
        for key, val in dict_.items():
            if isinstance(val, dict):  # maybe time dimension
                for k, v in val.items():
                    res[f"{key}_{k}"] = v
            else:
                res[key] = val
        return res
    return (pl_from_query,)


@app.cell
async def _(
    OrderBy,
    OrdersMembersFields,
    OrdersOrderByInput,
    Query,
    ResultFields,
    TimeDimensionFields,
    pl_from_query,
):
    _query = Query.cube().fields(
        ResultFields.orders(
            order_by=OrdersOrderByInput(created_at=OrderBy.asc)
        ).fields(
            OrdersMembersFields.created_at().fields(TimeDimensionFields.quarter),
            OrdersMembersFields.count_user,
        )
    )
    await pl_from_query(_query)
    return


if __name__ == "__main__":
    app.run()
